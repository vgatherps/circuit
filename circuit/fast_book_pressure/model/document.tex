\documentclass[]{article}
\usepackage{amsmath}

%opening
\title{Incrementally updating book fair}
\author{}

\begin{document}

\maketitle

\subsection{Overview}

The goal is to compute a single fair price $P^f$ using information in the orderbook, similarly to a weighted mid but over many levels. This will behave intelligently with imbalanced books (i.e. many offers, one ask) or books where prices aren't symmetric. This fair price will also NOT require a reference price to compute from. One could imagine an imbalance signal that is used to compute an adjustment from mid. We want to compute the price itself from first principles without relying on other prices (imagine if a tiny order shrinks a wide spread, giving a very misleading mid).


\subsection{Naively expanding weighted mid}

The plain weighted mid is equal to $\frac{P^b * S^a + P^a * S^b}{S^a + S^b}$. If we want to extend this to many levels, we might try: $\frac{\sum^i P^b_i * S^a_i + P^a_i * S^b_i}{\sum^i S^a_i + S^b_i}$. Immediately, this fails if we are not able to match every single ask with every single bid.
It also raises questions about why it even makes sense to compute. If there are gaps in one side of the book (i.e. wide spread, thin book), there's not a sensible way to match a level 3 levels deep on one side with something 2 levels deep on the other. This might be solvable in some way I haven't thought of, but it's entering a territory with ugly hacks and probably more parameters.

\subsection{Cost-minimization model}

We assume there is a fair price $P^f$ for the security that each market participant has a view of (this view differs between participants). We then say that each order in the book has some cost:

\begin{math}
	C_i = e^{-\lambda \cdot \pm (P_f - P_i )} f(S_i)
\end{math}

and the cost for the entire book is

\begin{equation}
\begin{split}
	C(P^f) &= \sum_{bids} e^{-\lambda (P_f - P^b_i )} f(S^b_i) + \sum_{asks} e^{-\lambda (P^a_i - P^f )} f(S^a_i) \\
	   &= e^{-\lambda P_f}\sum_{bids}  e^{\lambda P^b_i} f(S^b_i) +e^{\lambda P^f }  \sum_{asks}  e^{-\lambda P^a_i} f(S^a_i)
\end{split}
\end{equation}

Essentially, this is claiming that the cost of an order exponentially decreases as it gets deeper than the fair price, exponentially increases as the fair price crosses, and has some size-dependent multiplicative cost (in reality this could depend on many things, recency, queue position, executions, etc). For the purpose of this problem these costs are effectively constants and I'll write them as $K^{a,b}_i$

This cost function is convex as it's a sum of convex functions, so any minimum is the global minimum. The derivative w.r.t fair price is:

\begin{equation}
\begin{split}
	C(P^f)' &= (e^{-\lambda P_f}\sum_{bids}  e^{\lambda P^b_i} K^b_i +e^{\lambda P^f }  \sum_{asks}  e^{-\lambda P^a_i} K^a_i)' \\
	C(P^f)' &= -\lambda e^{-\lambda P_f}\sum_{bids}  e^{\lambda P^b_i} K^b_i + \lambda e^{\lambda P^f }  \sum_{asks}  e^{-\lambda P^a_i} K^a_i
\end{split}
\end{equation}

And setting this to zero we get

\begin{equation}
	\begin{split}
		0 &= -\lambda e^{-\lambda P_f}\sum_{bids}  e^{\lambda P^b_i} K^b_i + \lambda e^{\lambda P^f }  \sum_{asks}  e^{-\lambda P^a_i} K^a_i \\
		e^{-\lambda P_f}\sum_{bids}  e^{\lambda P^b_i} K^b_i &=  e^{\lambda P^f }  \sum_{asks}  e^{-\lambda P^a_i} K^a_i \\
		\frac{\sum_{bids}  e^{\lambda P^b_i} K^b_i}{\sum_{asks}  e^{-\lambda P^a_i} K^a_i} &=  e^{2\lambda P^f } \\
			P^f &=	\frac{ln(\frac{\sum_{bids}  e^{\lambda P^b_i} K^b_i}{\sum_{asks}  e^{-\lambda P^a_i} K^a_i})}{2\lambda} \\
	\end{split}
\end{equation}


\subsection{Normalizing}
The above formula will be impossible to compute properly - the exponentials will have gigantic intermediate values. This is easily remedied by normalizing with a reference price:

\begin{itemize}
	\item $P - P^{ref}$
	\item $\frac{P - P^{ref}}{{P^{ref}}}$
\end{itemize}

Each of these will compute a transformed fair price, and remove numerical issues. The second option slightly changes the problem as well. Instead of doing computations in price space, you are considering distance in percent-away-from reference. The reference has no impact at identical percentage differences,
however it of course does impact the percents themselves. In practice, this is effectively solved by using mid as a reasonable reference, with the assumption that mid and fair will never be more than a few basis points away from each other.

\subsection{Incremental updates without bookbuilding}

First, assume that the reference price stays constant. If we observe a change in $K_i$ for a given order (on order add assume was zero before), how do we update the above value without recomputing over the full book? This is a trivial computation - the two summations inside each log are linear in the cost of each order, so all that must be done is incrementally update with the delta of cost.

Take an order add - we simply add $e^{\pm \lambda P} K$ to the proper sum. For an execution, since we're given the executed shares, we just compute the equivalent $-K$ that the executed shared would imply. With a properly constructed calculation to update K, order add and executions don't even need to examine state in an order table since basically all major exchanges include the size delta in the message!

We also have to properly handle change-of-mid. For the linear adjustment, this is easy - simply multiplying by $e^(P^{new}-^{ref})$ will transform into a space with the new reference price.

However, the form $\frac{P - P^{ref}}{{P^{ref}}}$ is harder. Since there's no simple transformation from one reference to the other, a change of reference requires that one has a full book to recompute the incremental sums. This can be done infrequently by keeping a midpoint cached and only changing on when it's deviated too far. That computation can be done outside of the fast path, meaning the basis-points-from-mid can largely be done with no book manipulation as well

\end{document}
